#include<iostream>
using namespace std;
struct NODE{
    int data; //here as the node is representing the root so just int data
    struct NODE *left; //here as the left will also work as a root so node *left
    struct NODE *right; //here as the right will also work as a root so node *right
};
NODE *createNewNode(int x){
    NODE *newnode=new NODE;
    newnode->data=x;
    newnode->right=NULL;
    newnode->left=NULL;
    return newnode;
}
NODE *insert(NODE *root,int x){
    if(root==NULL){
        return createNewNode(x);
    }
    else if(x<=root->data){
        root->left=insert(root->left,x); //here we will be returning a new root left after insertion, and we update root->left with the result
    }
    else{
        root->right=insert(root->right,x);
        
    }
    return root;
}
NODE *find_min(NODE *root){
    while(root->left!=NULL){
        root=root->left;
    }
    return root;
}
NODE *deletion(NODE *root,int x){
    if(root==NULL){ //if the root is empty or the node to be deleted is not found then just return the root
        return root;
    }
    else if(x<root->data){
        root->left=deletion(root->left,x); //d->left=deletion() is because after deleting the node,it will return a new tree, place that to the left postion (d->lef
    }
    else if(x>root->data){
        root->right=deletion(root->right,x);
    }
    else{
        //here after searching from left or right once we found the element which is x==d->data  we will start the deletion process
        //case 1: no child
        if(root->left==NULL && root->right==NULL){
            delete root;
            root=NULL; //to make sure that deleted node exists no where in this tree
        }
        //case 2: 1 child
        else if(root->left==NULL){
            NODE *temp=root;
            root=root->right;
            delete temp;
        }
        else if(root->right==NULL){
            NODE *temp=root;
            root=root->left;
            delete temp;
        }
        //case 3: 2 child
        else{
            NODE *temp=find_min(root->right); //find the minimum of the right subtree
            root->data=temp->data;  //here we are changing the node to be deleted with the minimum_right one, so two nodes will be of the same amount (both the root and also that minimum_right)
            root->right=deletion(root->right,temp->data);
            //now we will be sending the right node and the temp->data to delete(the duplicate one as we have the root initialised as the same value)
        }
    }
    return root; //finally after deleting the node, lets return the modified one 
}
void Inorder(NODE *root){
    if(root==NULL) return;
    Inorder(root->left); //here after traversing left to left when we finally find the root to be null,that means the left of the root is null, so it will return to its caller which is Inorder(root->left) that root_>left==null and then it will print its next line which is cout<<root->data ,thats how the leftmost element will be printed (it follows a call stack mechanism)
    cout<<root->data<<"\t";
    Inorder(root->right);
}
void Preorder(NODE *root){
    if(root==NULL) return;
    cout<<root->data<<"\t";
    Preorder(root->left);
    Preorder(root->right);
}
void Postorder(NODE *root){
    if(root==NULL) return;
    Postorder(root->left);
    Postorder(root->right);
    cout<<root->data<<"\t";
}
int main(){
    NODE *root=NULL;
    root=insert(root,50);
    root=insert(root,45);
    root=insert(root,40);
    root=insert(root,35);
    root=insert(root,30);
    root=insert(root,25);
    root=insert(root,20);
    root=insert(root,15);
    root=insert(root,10);
    Inorder(root);
    cout<<endl;
    cout<<"Delete 20:"<<endl;
    root=deletion(root,20);
    Inorder(root);
    cout<<endl;
    cout<<"Delete 40:"<<endl;
    root=deletion(root,40);
    Inorder(root);
    cout<<endl;
}
